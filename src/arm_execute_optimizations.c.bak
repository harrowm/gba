/**
 * arm_execute_optimizations.c
 * 
 * Optimized ARM instruction execution using function pointer lookup tables.
 * This file implements optimizations for the ARM CPU execution core.
 */

#include "arm_execute_optimizations.h"
#include "arm_execute_phase1.h"
#include <stdint.h>
#include <stdbool.h>
#include <string.h> // For memset

// Function pointer tables
ConditionChecker arm_condition_table[16];
InstructionHandler arm_instruction_table[16];
ALUOperation arm_alu_operation_table[16];

// Forward declaration for instruction format detection
static uint32_t arm_get_instruction_format(uint32_t instruction);

// Forward declarations of instruction handler functions
static bool arm_handle_data_processing(ArmCPUState* state, uint32_t instruction, void* memory_interface);
static bool arm_handle_multiply(ArmCPUState* state, uint32_t instruction, void* memory_interface);
static bool arm_handle_single_data_transfer(ArmCPUState* state, uint32_t instruction, void* memory_interface);
static bool arm_handle_block_data_transfer(ArmCPUState* state, uint32_t instruction, void* memory_interface);
static bool arm_handle_branch(ArmCPUState* state, uint32_t instruction, void* memory_interface);
static bool arm_handle_coprocessor(ArmCPUState* state, uint32_t instruction, void* memory_interface);
static bool arm_handle_software_interrupt(ArmCPUState* state, uint32_t instruction, void* memory_interface);
static bool arm_handle_undefined(ArmCPUState* state, uint32_t instruction, void* memory_interface);

// Forward declarations for condition check functions
static bool arm_check_condition_eq(uint32_t cpsr);
static bool arm_check_condition_ne(uint32_t cpsr);
static bool arm_check_condition_cs(uint32_t cpsr);
static bool arm_check_condition_cc(uint32_t cpsr);
static bool arm_check_condition_mi(uint32_t cpsr);
static bool arm_check_condition_pl(uint32_t cpsr);
static bool arm_check_condition_vs(uint32_t cpsr);
static bool arm_check_condition_vc(uint32_t cpsr);
static bool arm_check_condition_hi(uint32_t cpsr);
static bool arm_check_condition_ls(uint32_t cpsr);
static bool arm_check_condition_ge(uint32_t cpsr);
static bool arm_check_condition_lt(uint32_t cpsr);
static bool arm_check_condition_gt(uint32_t cpsr);
static bool arm_check_condition_le(uint32_t cpsr);
static bool arm_check_condition_al(uint32_t cpsr);
static bool arm_check_condition_nv(uint32_t cpsr);

// Forward declarations for ALU operation functions
static uint32_t arm_alu_and(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_eor(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_sub(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_rsb(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_add(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_adc(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_sbc(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_rsc(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_tst(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_teq(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_cmp(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_cmn(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_orr(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_mov(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_bic(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);
static uint32_t arm_alu_mvn(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state);

// Precomputed condition results lookup table
// This is a 2D array indexed by [condition][flags]
// where flags is a 4-bit value representing N,Z,C,V
static bool condition_results[16][16];

/**
 * Initialize all optimization lookup tables
 */
void arm_initialize_optimization_tables(void) {
    // Initialize condition checker function table
    arm_condition_table[ARM_COND_EQ] = arm_check_condition_eq;
    arm_condition_table[ARM_COND_NE] = arm_check_condition_ne;
    arm_condition_table[ARM_COND_CS] = arm_check_condition_cs;
    arm_condition_table[ARM_COND_CC] = arm_check_condition_cc;
    arm_condition_table[ARM_COND_MI] = arm_check_condition_mi;
    arm_condition_table[ARM_COND_PL] = arm_check_condition_pl;
    arm_condition_table[ARM_COND_VS] = arm_check_condition_vs;
    arm_condition_table[ARM_COND_VC] = arm_check_condition_vc;
    arm_condition_table[ARM_COND_HI] = arm_check_condition_hi;
    arm_condition_table[ARM_COND_LS] = arm_check_condition_ls;
    arm_condition_table[ARM_COND_GE] = arm_check_condition_ge;
    arm_condition_table[ARM_COND_LT] = arm_check_condition_lt;
    arm_condition_table[ARM_COND_GT] = arm_check_condition_gt;
    arm_condition_table[ARM_COND_LE] = arm_check_condition_le;
    arm_condition_table[ARM_COND_AL] = arm_check_condition_al;
    arm_condition_table[ARM_COND_NV] = arm_check_condition_nv;
    
    // Initialize instruction handler function table
    arm_instruction_table[0] = arm_handle_data_processing; // Format 0: Data processing
    arm_instruction_table[1] = arm_handle_data_processing; // Format 1: Data processing immediate
    arm_instruction_table[2] = arm_handle_single_data_transfer; // Format 2: Single data transfer
    arm_instruction_table[3] = arm_handle_single_data_transfer; // Format 3: Single data transfer
    arm_instruction_table[4] = arm_handle_block_data_transfer;  // Format 4: Block data transfer
    arm_instruction_table[5] = arm_handle_branch;            // Format 5: Branch
    arm_instruction_table[6] = NULL;                         // Format 6: Coprocessor (not implemented)
    arm_instruction_table[7] = NULL;                         // Format 7: Coprocessor/SWI
    arm_instruction_table[8] = arm_handle_multiply;          // Special case: Multiply
    arm_instruction_table[9] = arm_handle_software_interrupt; // Special case: SWI
    // Fill remaining slots with NULL
    for (int i = 10; i < 16; i++) {
        arm_instruction_table[i] = NULL;
    }
    
    // Initialize ALU operation function table
    arm_alu_operation_table[ARM_OP_AND] = arm_alu_and;
    arm_alu_operation_table[ARM_OP_EOR] = arm_alu_eor;
    arm_alu_operation_table[ARM_OP_SUB] = arm_alu_sub;
    arm_alu_operation_table[ARM_OP_RSB] = arm_alu_rsb;
    arm_alu_operation_table[ARM_OP_ADD] = arm_alu_add;
    arm_alu_operation_table[ARM_OP_ADC] = arm_alu_adc;
    arm_alu_operation_table[ARM_OP_SBC] = arm_alu_sbc;
    arm_alu_operation_table[ARM_OP_RSC] = arm_alu_rsc;
    arm_alu_operation_table[ARM_OP_TST] = arm_alu_tst;
    arm_alu_operation_table[ARM_OP_TEQ] = arm_alu_teq;
    arm_alu_operation_table[ARM_OP_CMP] = arm_alu_cmp;
    arm_alu_operation_table[ARM_OP_CMN] = arm_alu_cmn;
    arm_alu_operation_table[ARM_OP_ORR] = arm_alu_orr;
    arm_alu_operation_table[ARM_OP_MOV] = arm_alu_mov;
    arm_alu_operation_table[ARM_OP_BIC] = arm_alu_bic;
    arm_alu_operation_table[ARM_OP_MVN] = arm_alu_mvn;
    
    // Initialize the condition results lookup table
    for (int flags = 0; flags < 16; flags++) {
        // Extract individual flags from the combined flags value
        bool n_flag = (flags & 0x8) != 0;  // Bit 3 for N
        bool z_flag = (flags & 0x4) != 0;  // Bit 2 for Z
        bool c_flag = (flags & 0x2) != 0;  // Bit 1 for C
        bool v_flag = (flags & 0x1) != 0;  // Bit 0 for V
        
        condition_results[ARM_COND_EQ][flags] = z_flag;
        condition_results[ARM_COND_NE][flags] = !z_flag;
        condition_results[ARM_COND_CS][flags] = c_flag;
        condition_results[ARM_COND_CC][flags] = !c_flag;
        condition_results[ARM_COND_MI][flags] = n_flag;
        condition_results[ARM_COND_PL][flags] = !n_flag;
        condition_results[ARM_COND_VS][flags] = v_flag;
        condition_results[ARM_COND_VC][flags] = !v_flag;
        condition_results[ARM_COND_HI][flags] = c_flag && !z_flag;
        condition_results[ARM_COND_LS][flags] = !c_flag || z_flag;
        condition_results[ARM_COND_GE][flags] = n_flag == v_flag;
        condition_results[ARM_COND_LT][flags] = n_flag != v_flag;
        condition_results[ARM_COND_GT][flags] = !z_flag && (n_flag == v_flag);
        condition_results[ARM_COND_LE][flags] = z_flag || (n_flag != v_flag);
        condition_results[ARM_COND_AL][flags] = true;
        condition_results[ARM_COND_NV][flags] = true;  // NV is treated as AL in ARMv4
    }
}

/**
 * Optimized instruction execution entry point
 */
bool arm_execute_instruction_optimized(ArmCPUState* state, uint32_t instruction, ArmMemoryInterface* memory_interface) {
    // Check condition first using the condition table
    ARMCondition condition = (ARMCondition)ARM_GET_CONDITION(instruction);
    
    // Fast condition check using the condition table
    if (!arm_condition_table[condition](state->cpsr)) {
        return false; // Condition failed, PC not modified
    }
    
    // Get instruction format and dispatch to handler
    uint32_t format = arm_get_instruction_format(instruction);
    if (arm_instruction_table[format] != NULL) {
        return arm_instruction_table[format](state, instruction, memory_interface);
    }
    
    return false; // Unimplemented instruction handler
}

/**
 * Determine the instruction format for dispatch table lookups
 */
uint32_t arm_get_instruction_format(uint32_t instruction) {
    uint32_t format = (instruction >> 25) & 0x7;  // Bits 27-25
    
    // Special case detection for multiply and SWI
    if (format == 0 && (instruction & 0x0F8000F0) == 0x00000090) {
        return 8;  // Multiply instruction
    } else if (format == 7 && (instruction & 0x0F000000) == 0x0F000000) {
        return 9;  // Software interrupt
    }
    
    return format;
}

/*
 * Instruction handler implementations
 */

static bool arm_handle_data_processing(ArmCPUState* state, uint32_t instruction, void* memory_interface_void) {
    ArmMemoryInterface* memory_interface = (ArmMemoryInterface*)memory_interface_void;
    return arm_execute_data_processing_optimized(state, instruction, memory_interface);
}

static bool arm_handle_multiply(ArmCPUState* state, uint32_t instruction, void* memory_interface_void) {
    return arm_execute_multiply(state, instruction);
}

static bool arm_handle_single_data_transfer(ArmCPUState* state, uint32_t instruction, void* memory_interface_void) {
    ArmMemoryInterface* memory_interface = (ArmMemoryInterface*)memory_interface_void;
    return arm_execute_single_data_transfer(state, instruction, memory_interface);
}

static bool arm_handle_block_data_transfer(ArmCPUState* state, uint32_t instruction, void* memory_interface_void) {
    ArmMemoryInterface* memory_interface = (ArmMemoryInterface*)memory_interface_void;
    return arm_execute_block_data_transfer(state, instruction, memory_interface);
}

static bool arm_handle_branch(ArmCPUState* state, uint32_t instruction, void* memory_interface_void) {
    return arm_execute_branch(state, instruction);
}

static bool arm_handle_coprocessor(ArmCPUState* state, uint32_t instruction, void* memory_interface_void) {
    // Coprocessor instructions are not implemented yet
    return false;
}

static bool arm_handle_software_interrupt(ArmCPUState* state, uint32_t instruction, void* memory_interface_void) {
    return arm_execute_software_interrupt(state, instruction);
}

static bool arm_handle_undefined(ArmCPUState* state, uint32_t instruction, void* memory_interface_void) {
    // Handle undefined instruction - not implemented yet
    return false;
}

// Individual condition check functions
static bool arm_check_condition_eq(uint32_t cpsr) {
    return (cpsr & ARM_FLAG_Z) != 0; // Z set
}

static bool arm_check_condition_ne(uint32_t cpsr) {
    return (cpsr & ARM_FLAG_Z) == 0; // Z clear
}

static bool arm_check_condition_cs(uint32_t cpsr) {
    return (cpsr & ARM_FLAG_C) != 0; // C set
}

static bool arm_check_condition_cc(uint32_t cpsr) {
    return (cpsr & ARM_FLAG_C) == 0; // C clear
}

static bool arm_check_condition_mi(uint32_t cpsr) {
    return (cpsr & ARM_FLAG_N) != 0; // N set
}

static bool arm_check_condition_pl(uint32_t cpsr) {
    return (cpsr & ARM_FLAG_N) == 0; // N clear
}

static bool arm_check_condition_vs(uint32_t cpsr) {
    return (cpsr & ARM_FLAG_V) != 0; // V set
}

static bool arm_check_condition_vc(uint32_t cpsr) {
    return (cpsr & ARM_FLAG_V) == 0; // V clear
}

static bool arm_check_condition_hi(uint32_t cpsr) {
    return ((cpsr & ARM_FLAG_C) != 0) && ((cpsr & ARM_FLAG_Z) == 0); // C set and Z clear
}

static bool arm_check_condition_ls(uint32_t cpsr) {
    return ((cpsr & ARM_FLAG_C) == 0) || ((cpsr & ARM_FLAG_Z) != 0); // C clear or Z set
}

static bool arm_check_condition_ge(uint32_t cpsr) {
    bool n = (cpsr & ARM_FLAG_N) != 0;
    bool v = (cpsr & ARM_FLAG_V) != 0;
    return n == v; // N == V
}

static bool arm_check_condition_lt(uint32_t cpsr) {
    bool n = (cpsr & ARM_FLAG_N) != 0;
    bool v = (cpsr & ARM_FLAG_V) != 0;
    return n != v; // N != V
}

static bool arm_check_condition_gt(uint32_t cpsr) {
    bool z = (cpsr & ARM_FLAG_Z) != 0;
    bool n = (cpsr & ARM_FLAG_N) != 0;
    bool v = (cpsr & ARM_FLAG_V) != 0;
    return !z && (n == v); // Z clear and N == V
}

static bool arm_check_condition_le(uint32_t cpsr) {
    bool z = (cpsr & ARM_FLAG_Z) != 0;
    bool n = (cpsr & ARM_FLAG_N) != 0;
    bool v = (cpsr & ARM_FLAG_V) != 0;
    return z || (n != v); // Z set or N != V
}

static bool arm_check_condition_al(uint32_t cpsr) {
    return true; // Always
}

static bool arm_check_condition_nv(uint32_t cpsr) {
    return true; // Never (treated as always in ARMv4)
}

// Individual ALU operation functions
static uint32_t arm_alu_and_wrapper(ArmCPUState* state, uint32_t op1, uint32_t op2, uint32_t* carry_out, bool set_flags) {
    uint32_t result = op1 & op2;
    if (set_flags) arm_update_flags(state, result, *carry_out, true);
    return result;
}

static uint32_t arm_alu_and(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 & op2;
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags(state, result, *carry_out, true);
    return result;
}

static uint32_t arm_alu_eor(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 ^ op2;
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags(state, result, *carry_out, true);
    return result;
}

static uint32_t arm_alu_sub(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 - op2;
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags_sub(state, op1, op2, result, true);
    return result;
}

static uint32_t arm_alu_rsb(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op2 - op1;
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags_sub(state, op2, op1, result, true);
    return result;
}

static uint32_t arm_alu_add(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 + op2;
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags_add(state, op1, op2, result, true);
    return result;
}

static uint32_t arm_alu_adc(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t carry_in = (state->cpsr & ARM_FLAG_C) ? 1 : 0;
    uint32_t result = op1 + op2 + carry_in;
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags_add(state, op1, op2 + carry_in, result, true);
    return result;
}

static uint32_t arm_alu_sbc(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t carry_in = (state->cpsr & ARM_FLAG_C) ? 1 : 0;
    uint32_t result = op1 - op2 - (1 - carry_in);
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags_sub(state, op1, op2 + (1 - carry_in), result, true);
    return result;
}

static uint32_t arm_alu_rsc(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t carry_in = (state->cpsr & ARM_FLAG_C) ? 1 : 0;
    uint32_t result = op2 - op1 - (1 - carry_in);
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags_sub(state, op2, op1 + (1 - carry_in), result, true);
    return result;
}

static uint32_t arm_alu_tst(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 & op2;
    arm_update_flags(state, result, *carry_out, true); // TST always sets flags
    return result; // Result not stored
}

static uint32_t arm_alu_teq(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 ^ op2;
    arm_update_flags(state, result, *carry_out, true); // TEQ always sets flags
    return result; // Result not stored
}

static uint32_t arm_alu_cmp(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 - op2;
    arm_update_flags_sub(state, op1, op2, result, true); // CMP always sets flags
    return result; // Result not stored
}

static uint32_t arm_alu_cmn(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 + op2;
    arm_update_flags_add(state, op1, op2, result, true); // CMN always sets flags
    return result; // Result not stored
}

static uint32_t arm_alu_orr(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 | op2;
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags(state, result, *carry_out, true);
    return result;
}

static uint32_t arm_alu_mov(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op2; // MOV ignores op1
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags(state, result, *carry_out, true);
    return result;
}

static uint32_t arm_alu_bic(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = op1 & ~op2;
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags(state, result, *carry_out, true);
    return result;
}

static uint32_t arm_alu_mvn(uint32_t op1, uint32_t op2, uint32_t* carry_out, ArmCPUState* state) {
    uint32_t result = ~op2; // MVN ignores op1
    bool set_flags = ARM_GET_S_BIT(state->cpsr);
    if (set_flags) arm_update_flags(state, result, *carry_out, true);
    return result;
}

/**
 * Execute ARM data processing instruction using optimized ALU operation table
 */
bool arm_execute_data_processing_optimized(ArmCPUState* state, uint32_t instruction, ArmMemoryInterface* memory_interface) {
    // Get the opcode field
    uint32_t opcode = (instruction >> 21) & 0xF;
    
    // Extract operand fields
    uint32_t rn = (instruction >> 16) & 0xF;
    uint32_t rd = (instruction >> 12) & 0xF;
    uint32_t operand1 = state->registers[rn];
    uint32_t operand2 = 0;
    uint32_t carry_out = (state->cpsr & ARM_FLAG_C) ? 1 : 0;
    
    // Get second operand value based on I bit
    if (instruction & (1 << 25)) {
        // Immediate operand (I = 1)
        uint32_t imm = instruction & 0xFF;
        uint32_t rotate = ((instruction >> 8) & 0xF) * 2;
        operand2 = ARM_ROTATE_RIGHT(imm, rotate);
        if (rotate > 0) {
            carry_out = (operand2 >> 31) & 1;
        }
    } else {
        // Register operand (I = 0)
        uint32_t rm = instruction & 0xF;
        operand2 = state->registers[rm];
        
        // Process shift
        uint32_t shift_type = (instruction >> 5) & 0x3;
        uint32_t shift_amount = 0;
        
        if (instruction & (1 << 4)) {
            // Register shift
            uint32_t rs = (instruction >> 8) & 0xF;
            shift_amount = state->registers[rs] & 0xFF;
        } else {
            // Immediate shift
            shift_amount = (instruction >> 7) & 0x1F;
        }
        
        // Apply shift
        switch(shift_type) {
            case 0: // LSL
                if (shift_amount > 0) {
                    carry_out = (operand2 >> (32 - shift_amount)) & 1;
                    operand2 = operand2 << shift_amount;
                }
                break;
            case 1: // LSR
                if (shift_amount > 0) {
                    carry_out = (operand2 >> (shift_amount - 1)) & 1;
                    operand2 = operand2 >> shift_amount;
                }
                break;
            case 2: // ASR
                if (shift_amount > 0) {
                    carry_out = (operand2 >> (shift_amount - 1)) & 1;
                    operand2 = (int32_t)operand2 >> shift_amount;
                }
                break;
            case 3: // ROR
                if (shift_amount > 0) {
                    carry_out = (operand2 >> (shift_amount - 1)) & 1;
                    operand2 = ARM_ROTATE_RIGHT(operand2, shift_amount);
                }
                break;
        }
    }
    
    // Execute ALU operation using the function pointer table
    uint32_t result = arm_alu_operation_table[opcode](operand1, operand2, &carry_out, state);
    
    // Store result if this is not a test/compare operation
    if (!(opcode == ARM_OP_TST || opcode == ARM_OP_TEQ || opcode == ARM_OP_CMP || opcode == ARM_OP_CMN)) {
        if (rd == 15) { // PC is register 15
            // Handle PC write
            state->registers[rd] = result;
            return true;  // PC modified
        } else {
            state->registers[rd] = result;
        }
    }
    
    return false;  // PC not modified
}
