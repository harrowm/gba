// test_thumb10.cpp - Refactored Thumb CPU test fixture
#include "thumb_test_base.h"

class ThumbCPUTest10 : public ThumbCPUTestBase {
protected:
    void SetUp() override {
        ThumbCPUTestBase::SetUp();
    }
};
protected:
    }
    void SetUp() override {
    }
    }
        }
        } else {
            }
        }
    }
        }
        }
    }
};
TEST_F(ThumbCPUTest10, StrhBasic) {
    // Test case: STRH R0, [R1, #0] - minimum offset
    setup_registers({{1, 0x00001000}, {0, 0x12345678}});
    registers()[15] = 0x00000000;
    
    ASSERT_TRUE(assembleAndWriteThumb("strh r0, [r1, #0]", registers()[15]));
    execute(1);
    
    // Verify only the lower 16 bits were stored
    uint16_t stored = memory.read16(0x00001000);
    EXPECT_EQ(stored, 0x5678u);
    EXPECT_EQ(registers()[15], 0x00000002u);
}

TEST_F(ThumbCPUTest10, StrhWithOffset) {
    // Test case: STRH R2, [R3, #2] - basic offset
    setup_registers({{3, 0x00001000}, {2, 0x87654321}});
    registers()[15] = 0x00000000;
    
    ASSERT_TRUE(assembleAndWriteThumb("strh r2, [r3, #2]", registers()[15]));
    execute(1);
    
    // Verify halfword stored at base + 2
    uint16_t stored = memory.read16(0x00001002);
    EXPECT_EQ(stored, 0x4321u);
    EXPECT_EQ(registers()[15], 0x00000002u);
}

TEST_F(ThumbCPUTest10, StrhDifferentOffsets) {
    // Test different halfword offsets to ensure Thumb-1 generation
    setup_registers({{4, 0x00001000}});
    
    struct TestCase {
        uint32_t halfword_offset;
        uint32_t test_value;
    };
    
    TestCase test_cases[] = {
        {4, 0xAAAA1111},   // offset5=2 -> 4 bytes
        {8, 0xBBBB2222},   // offset5=4 -> 8 bytes  
        {12, 0xCCCC3333},  // offset5=6 -> 12 bytes
        {20, 0xDDDD4444},  // offset5=10 -> 20 bytes
        {30, 0xEEEE5555}   // offset5=15 -> 30 bytes
    };
    
    for (size_t i = 0; i < sizeof(test_cases)/sizeof(test_cases[0]); i++) {
        registers()[5] = test_cases[i].test_value;
        registers()[15] = i * 4; // Set PC for each test
        
        std::string instruction = "strh r5, [r4, #" + std::to_string(test_cases[i].halfword_offset) + "]";
        ASSERT_TRUE(assembleAndWriteThumb(instruction, registers()[15]));
        execute(1);
        
        // Verify halfword stored at correct address
        uint16_t stored = memory.read16(0x00001000 + test_cases[i].halfword_offset);
        uint16_t expected = test_cases[i].test_value & 0xFFFF;
        EXPECT_EQ(stored, expected) << "Offset " << test_cases[i].halfword_offset;
        EXPECT_EQ(registers()[15], static_cast<uint32_t>(i * 4 + 2));
    }
}

TEST_F(ThumbCPUTest10, StrhAllRegisters) {
    // Test storing from different source registers
    setup_registers({{0, 0x00001000}});
    
    for (int rd = 1; rd < 8; rd++) { // Skip R0 since it's the base
        uint32_t test_value = 0x1000 + rd;
        registers()[rd] = test_value;
        registers()[15] = rd * 4; // Different PC for each test
        
        // Use offset #4 for all to avoid overlap
        std::string instruction = "strh r" + std::to_string(rd) + ", [r0, #4]";
        ASSERT_TRUE(assembleAndWriteThumb(instruction, registers()[15]));
        execute(1);
        
        // Verify halfword stored (each test overwrites the same location)
        uint16_t stored = memory.read16(0x00001004);
        EXPECT_EQ(stored, static_cast<uint16_t>(test_value & 0xFFFF)) << "Register R" << rd;
        EXPECT_EQ(registers()[15], static_cast<uint32_t>(rd * 4 + 2));
    }
}

TEST_F(ThumbCPUTest10, StrhMaximumOffset) {
    // Test maximum halfword offset to ensure Format 10
    setup_registers({{0, 0x00001000}, {7, 0x11223344}});
    registers()[15] = 0x00000000;
    
    ASSERT_TRUE(assembleAndWriteThumb("strh r7, [r0, #62]", registers()[15]));
    execute(1);
    
    // Verify halfword stored at maximum offset (offset5=31 -> 62 bytes)
    uint16_t stored = memory.read16(0x0000103E);
    EXPECT_EQ(stored, 0x3344u);
    EXPECT_EQ(registers()[15], 0x00000002u);
}

TEST_F(ThumbCPUTest10, LdrhBasic) {
    // Test case: LDRH R0, [R1, #0] - minimum offset
    setup_registers({{1, 0x00001000}});
    registers()[15] = 0x00000000;
    
    // Pre-store a halfword value
    memory.write16(0x00001000, 0x5678);
    
    ASSERT_TRUE(assembleAndWriteThumb("ldrh r0, [r1, #0]", registers()[15]));
    execute(1);
    
    // Verify halfword loaded and zero-extended
    EXPECT_EQ(registers()[0], 0x00005678u);
    EXPECT_EQ(registers()[15], 0x00000002u);
}

TEST_F(ThumbCPUTest10, LdrhWithOffset) {
    // Test case: LDRH R2, [R3, #2] - basic offset
    setup_registers({{3, 0x00001000}});
    registers()[15] = 0x00000000;
    
    // Pre-store a halfword value
    memory.write16(0x00001002, 0x4321);
    
    ASSERT_TRUE(assembleAndWriteThumb("ldrh r2, [r3, #2]", registers()[15]));
    execute(1);
    
    // Verify halfword loaded and zero-extended
    EXPECT_EQ(registers()[2], 0x00004321u);
    EXPECT_EQ(registers()[15], 0x00000002u);
}

TEST_F(ThumbCPUTest10, LdrhDifferentOffsets) {
    // Test loading halfwords from different offsets
    setup_registers({{1, 0x00001000}});
    
    struct TestCase {
        uint32_t halfword_offset;
        uint16_t test_value;
    };
    
    TestCase test_cases[] = {
        {6, 0xAAAA},   // offset5=3 -> 6 bytes
        {10, 0xBBBB},  // offset5=5 -> 10 bytes
        {16, 0xCCCC},  // offset5=8 -> 16 bytes
        {24, 0xDDDD},  // offset5=12 -> 24 bytes
        {32, 0xEEEE}   // offset5=16 -> 32 bytes (keep reasonable for Thumb-1)
    };
    
    for (size_t i = 0; i < sizeof(test_cases)/sizeof(test_cases[0]); i++) {
        // Pre-store value in memory
        memory.write16(0x00001000 + test_cases[i].halfword_offset, test_cases[i].test_value);
        
        registers()[0] = 0xDEADBEEF; // Reset destination
        registers()[15] = i * 4; // Set PC for each test
        
        std::string instruction = "ldrh r0, [r1, #" + std::to_string(test_cases[i].halfword_offset) + "]";
        ASSERT_TRUE(assembleAndWriteThumb(instruction, registers()[15]));
        execute(1);
        
        // Verify halfword loaded and zero-extended correctly
        EXPECT_EQ(registers()[0], static_cast<uint32_t>(test_cases[i].test_value)) 
            << "Offset " << test_cases[i].halfword_offset;
        EXPECT_EQ(registers()[15], static_cast<uint32_t>(i * 4 + 2));
    }
}

TEST_F(ThumbCPUTest10, LdrhAllRegisters) {
    // Test loading into different destination registers
    uint16_t test_value = 0x6000;
    
    for (int rd = 0; rd < 8; rd++) {
        setup_registers({{1, 0x00001000}}); // Reset and set base
        
        // Pre-store value in memory at offset 16 from base
        memory.write16(0x00001010, test_value);
        
        registers()[15] = rd * 4; // Set PC for each test
        
        std::string instruction = "ldrh r" + std::to_string(rd) + ", [r1, #16]";
        ASSERT_TRUE(assembleAndWriteThumb(instruction, registers()[15]));
        execute(1);
        
        // Verify halfword loaded into correct register
        EXPECT_EQ(registers()[rd], static_cast<uint32_t>(test_value)) << "Register R" << rd;
        EXPECT_EQ(registers()[15], static_cast<uint32_t>(rd * 4 + 2));
    }
}

TEST_F(ThumbCPUTest10, StrhLdrhRoundtrip) {
    // Test storing and loading halfwords to verify consistency
    setup_registers({{1, 0x00001000}});
    
    uint16_t test_values[] = {0x0000, 0x1234, 0xFFFF, 0x8000, 0x7FFF};
    uint32_t test_offsets[] = {0, 2, 4, 6, 8}; // Use small offsets to ensure Thumb-1 generation
    
    for (size_t i = 0; i < sizeof(test_values)/sizeof(test_values[0]); i++) {
        registers()[0] = test_values[i];
        registers()[15] = i * 8; // Different PC for store and load
        
        // Store halfword
        std::string store_instr = "strh r0, [r1, #" + std::to_string(test_offsets[i]) + "]";
        ASSERT_TRUE(assembleAndWriteThumb(store_instr, registers()[15]));
        execute(1);
        
        // Load back
        registers()[2] = 0xDEADBEEF;
        registers()[15] = i * 8 + 2;
        
        std::string load_instr = "ldrh r2, [r1, #" + std::to_string(test_offsets[i]) + "]";
        ASSERT_TRUE(assembleAndWriteThumb(load_instr, registers()[15]));
        execute(1);
        
        // Verify halfword round-trip
        EXPECT_EQ(registers()[2], static_cast<uint32_t>(test_values[i])) 
            << "Halfword 0x" << std::hex << test_values[i] << " at offset " << test_offsets[i];
        EXPECT_EQ(registers()[15], static_cast<uint32_t>(i * 8 + 4));
    }
}

TEST_F(ThumbCPUTest10, EdgeCasesAndBoundaryConditions) {
    // Test edge cases while keeping within memory bounds
    
    // Test zero offset
    setup_registers({{4, 0x00001500}, {5, 0x11223344}});
    registers()[15] = 0x00000000;
    
    ASSERT_TRUE(assembleAndWriteThumb("strh r5, [r4, #0]", registers()[15]));
    execute(1);
    
    // Verify stored at base address
    uint16_t stored = memory.read16(0x00001500);
    EXPECT_EQ(stored, 0x3344u);
    
    // Load back with zero offset
    registers()[6] = 0xDEADBEEF;
    registers()[15] = 0x00000002;
    
    ASSERT_TRUE(assembleAndWriteThumb("ldrh r6, [r4, #0]", registers()[15]));
    execute(1);
    
    EXPECT_EQ(registers()[6], 0x00003344u);
    EXPECT_EQ(registers()[15], 0x00000004u);
}

TEST_F(ThumbCPUTest10, ComprehensiveOffsetRangeTest) {
    // Test all 32 possible offset values (0, 2, 4, 6, ..., 62)
    // This ensures complete coverage of the 5-bit offset field
    setup_registers({{1, 0x00001000}});  // Base address
    
    for (int byte_offset = 0; byte_offset <= 62; byte_offset += 2) {
        // Clear memory region for this test (only the specific range we need)
        for (uint32_t addr = 0x00001000; addr <= 0x0000103E; addr += 2) {
            memory.write16(addr, 0);
        }
        
        uint16_t test_value = 0x3000 + byte_offset;  // Unique value for each offset
        registers()[2] = test_value;
        registers()[15] = byte_offset * 2;  // Different PC for each test
        
        // Test STRH with this offset
        std::string strh_instruction = "strh r2, [r1, #" + std::to_string(byte_offset) + "]";
        ASSERT_TRUE(assembleAndWriteThumb(strh_instruction, registers()[15])) 
            << "Failed to assemble STRH with offset " << byte_offset;
        execute(1);
        
        // Verify the halfword was stored at the correct address
        uint16_t stored_value = memory.read16(0x00001000 + byte_offset);
        EXPECT_EQ(stored_value, test_value) 
            << "STRH failed for offset " << byte_offset;
        EXPECT_EQ(registers()[15], static_cast<uint32_t>(byte_offset * 2 + 2)) 
            << "PC incorrect after STRH with offset " << byte_offset;
        
        // Test LDRH with the same offset
        registers()[3] = 0xDEADBEEF;  // Clear destination register
        registers()[15] = byte_offset * 2 + 64;  // Different PC for load instruction
        
        std::string ldrh_instruction = "ldrh r3, [r1, #" + std::to_string(byte_offset) + "]";
        ASSERT_TRUE(assembleAndWriteThumb(ldrh_instruction, registers()[15])) 
            << "Failed to assemble LDRH with offset " << byte_offset;
        execute(1);
        
        // Verify the halfword was loaded correctly
        EXPECT_EQ(registers()[3], static_cast<uint32_t>(test_value)) 
            << "LDRH failed for offset " << byte_offset;
        EXPECT_EQ(registers()[15], static_cast<uint32_t>(byte_offset * 2 + 66)) 
            << "PC incorrect after LDRH with offset " << byte_offset;
    }
}

TEST_F(ThumbCPUTest10, AllRegisterCombinations) {
    // Test various register combinations at different offsets within memory bounds
    setup_registers({{0, 0x00001000}, {1, 0x00001100}, {2, 0x00001200}});
    
    // Test a few combinations to verify instruction generation
    uint16_t test_value0 = 0x1111;
    uint16_t test_value1 = 0x2222; 
    uint16_t test_value2 = 0x3333;
    
    // Store test values in source registers for STRH
    registers()[3] = test_value0;  // Use R3 as source
    registers()[4] = test_value1;  // Use R4 as source
    registers()[5] = test_value2;  // Use R5 as source
    
    registers()[15] = 0x00000000;
    
    // STRH R3, [R1, #4]
    ASSERT_TRUE(assembleAndWriteThumb("strh r3, [r1, #4]", registers()[15]));
    execute(1);
    
    // STRH R4, [R2, #6] 
    registers()[15] = 0x00000004;
    ASSERT_TRUE(assembleAndWriteThumb("strh r4, [r2, #6]", registers()[15]));
    execute(1);
    
    // STRH R5, [R0, #8]
    registers()[15] = 0x00000008;
    ASSERT_TRUE(assembleAndWriteThumb("strh r5, [r0, #8]", registers()[15]));
    execute(1);
    
    // Verify PC advanced correctly
    EXPECT_EQ(registers()[15], 0x0000000Au);
    
    // Verify stores happened at correct addresses
    uint16_t stored1 = memory.read16(0x00001104);  // R1 base + 4
    EXPECT_EQ(stored1, test_value0);
    
    uint16_t stored2 = memory.read16(0x00001206);  // R2 base + 6  
    EXPECT_EQ(stored2, test_value1);
    
    uint16_t stored3 = memory.read16(0x00001008);  // R0 base + 8
    EXPECT_EQ(stored3, test_value2);
}
